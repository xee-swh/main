# redis
## 数据结构
 string
 list
 ...
 
## 高可用
Redis高可用回答包括两个层面，一个就是数据不能丢失，或者说尽量减少丢失;另外一个就是保证Redis服务不中断。

对于尽量减少数据丢失，可以通过AOF和RDB保证。
对于保证服务不中断的话，Redis就不能单点部署，这时候我们先看下Redis主从。

1、主从   
2、哨兵   
3、集群    




## 问题与解决方案
### 缓存击穿
   
   缓存击穿是针对一个缓存key来说的，当一个热点key过期后,大量用户请求同一个key，这时候就会直接查询数据库，
导致数据库压力瞬间在增加造成大量请求阻塞，

#### 解决办法1:
   
   设置key永不过期，实现比较简单，还有一种方式也可以达到key不过期的目的，就是正常给key设置过期时间，
   在后台同事启动一个定时任务去定时地更新这个缓存。类似于监控哪些是热点数据，续期。
   
#### 解决办法2:

   使用分布式锁，保证同一时刻只能有一个查询请求进入，从而将热点数据加载到缓存中，这样，其他的现成
   只需要等待该线程运行完毕，即可重新从缓存中获取数据。

### 缓存穿透

   缓存穿透是指查询一个缓存中和数据库中都不存在的数据，导致每次查询这条数据都会穿过缓存，直接查库，最后返回空。
   当用户使用这条不存在的数据发起大量查询请求的时候，对数据库造成的压力就非常大，甚至可能挂掉。
   
#### 解决办法1：

   缓存空对象
   数据库查不到的时候，缓存空对象，并且设置过期时间，下次就从缓存中拿。
   
   缺点：
   1占用了内存空间。
   2可能导致缓存层和存储层的数据不一致。
   
####  解决办法2：

   使用布隆过滤器
   
   
   
3、缓存雪崩




## 优化



## 日志


## 扩展
 save 和 bgsave命令
 只有在触发这2个命令的时候，才生成rdb文件。
 save命令有服务器进程直接执行保存操作，该命令会阻塞服务器
 bgsave命令由子进程执行保存操作，该命令不会阻塞服务器
 
 配置文件中配置了save选项的保存条件，当满足一个保存条件时，服务器都会执行BGSAVE命令
 
 






















# 常见

## redis常用数据结构
