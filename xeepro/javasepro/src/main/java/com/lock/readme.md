# 锁
## synchronized
    关键字
    是对对象进行加锁的
    底层是C语言实现的
    原理是锁对象的对象头
    
    synchronized 的作用主要有三：
    （1）、原子性：所谓原子性就是指一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，
          要么就都不执行。被synchronized修饰的类或对象的所有操作都是原子的，因为在执行操作之前必须
          先获得类或对象的锁，直到执行完才能释放。
    （2）、可见性：**可见性是指多个线程访问一个资源时，该资源的状态、值信息等对于其他线程都是可见的。 
          **synchronized和volatile都具有可见性，其中synchronized对一个类或对象加锁时，一个线程
          如果要访问该类或对象必须先获得它的锁，而这个锁的状态对于其他任何线程都是可见的，并且在释放锁
          之前会将对变量的修改刷新到共享内存当中，保证资源变量的可见性。
    （3）、有序性：有序性值程序执行的顺序按照代码先后执行。 synchronized和volatile都具有有序性，Java
          允许编译器和处理器对指令进行重排，但是指令重排并不会影响单线程的顺序，它影响的是多线程并发执行
          的顺序性。synchronized保证了每个时刻都只有一个线程访问同步代码块，也就确定了线程执行同步代码
          块是分先后顺序的，保证了有序性。
    
    任何一个对象都有一个Monitor与之关联，当且一个Monitor被持有后，它将处于锁定状态。Synchronized在JVM里
    的实现都是 基于进入和退出Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成
    对的MonitorEnter和MonitorExit指令来实现。
    
    MonitorEnter指令：插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，
    即尝试获得该对象的锁；
    MonitorExit指令：插入在方法结束处和异常处，JVM保证每个MonitorEnter必须有对应的MonitorExit；
   
    在Java的设计中，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。 
    也就是通常说Synchronized的对象锁，MarkWord锁标识位为10，其中指针指向的是Monitor对象的起始地址。
    在Java虚拟机（HotSpot）中，Monitor是由ObjectMonitor实现的。
    
    从JDK5引入了现代操作系统新增加的CAS原子操作（JDK5中并没有对synchronized关键字做优化，
    而是体现在J.U.C中，所以在该版本concurrent包有更好的性能），从JDK6开始，就对synchronized
    的实现机制进行了较大调整，包括使用JDK5引进的CAS自旋之外，还增加了自适应的CAS自旋、锁消除、
    锁粗化、偏向锁、轻量级锁这些优化策略。由于此关键字的优化使得性能极大提高，同时语义清晰、操作简单、
    无需手动关闭，所以推荐在允许的情况下尽量使用此关键字，同时在性能上此关键字还有优化的空间。
    
    锁主要存在四种状态：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。
    每种锁是只能升级，不能降级，即由偏向锁->轻量级锁->重量级锁，而这个过程就是开销逐渐加大的过程。
    如果是单线程使用，那偏向锁毫无疑问代价最小，并且它就能解决问题，连CAS都不用做，仅仅在内存中
    比较下对象头就可以了；如果出现了其他线程竞争，则偏向锁就会升级为轻量级锁；如果其他线程通过一定
    次数的CAS尝试没有成功，则进入重量级锁；

    锁的优缺点对比如下
    锁	        优点	                                            缺点	                                         适用场景
    偏向锁	  加锁和解锁不需要额外的消耗，和执行非同步方法仅有纳米级的差距	如果线程间存在锁的竞争，会带来额外的锁撤销的消耗	适用于只有一个线程访问的同步块场景
    轻量级锁	  竞争的线程不会阻塞，提高了程序的相应速度	                如果始终得不到锁竞争的线程，使用自旋会消耗CPU	追求响应时间，同步响应非常快
    重量级锁	  线程竞争不使用自旋，不会消耗CPU	                        线程阻塞，响应时间缓慢	                    追求吞吐量，同步块执行速度较长
## ReentrantLock
    ReentrantLock实现了Lock接口
    需要手工加锁和释放锁，
    默认是创建非公平锁： new NonfairSync()，
    可以通过参数创建公平锁:  new FairSync()，
    内部维护了一个抽象类: Sync,该类继承了AQS(AbstractQueuedSynchronizer)，
    在进行加锁处理的时候，进行了cas(compareAndSetState)操作，
    
    在AQS里面，维护了一个状态：state,使用了volatile修饰。AbstractQueuedSynchronizer
    的state状态值定义为线程获取该锁的重入次数，state状态值为0表示当前没有被任何线程持有，
    state状态值为1表示被其他线程持有，因为支持可重入，如果是持有锁的线程，再次获取同一把锁，
    直接成功，并且state状态值+1，线程释放锁state状态值-1，同理重入多次锁的线程，需要释放相应的次数。
    
    AbstractQueuedSynchronizer抽象类定义了一套多线程访问共享资源的同步模板，解决了实现同步器
    时涉及的大量细节问题，能够极大地减少实现工作，为加锁和解锁过程提供了统一的模板函数，只有少量
    细节由子类自己决定。
    AQS中，加锁与解锁的模板流程是，获取锁失败的线程，会进入CLH队列阻塞，其他线程解锁
    会唤醒CLH队列线程，线程释放锁时，会唤醒CLH队列阻塞的线程，重新竞争锁，要注意，此时可能还有非
    CLH队列的线程参与竞争，所以非公平就体现在这里，非CLH队列线程与CLH队列线程竞争，各凭本事，
    不会因为你是CLH队列的线程，排了很久的队，就把锁让给你。
    
    总结：ReentrantLock是可重入的互斥锁，底层是基于AbstractQueuedSynchronizer实现，
    
    
## synchronized与ReentrantLock区别

### 使用上
    synchronized作为关键字，是JVM级别的，直接使用
    ReentrantLock作为api层级的，需要手工加锁，释放锁。
    ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁
### 原理上
    synchronized是对Monitor加锁标志，使用MonitorEnter和MonitorExit来判断对象的加锁和释放锁。新版本中也使用CAS来实现。
    ReentrantLock底层是使用AQS来做的，结合CAS来实现的加锁和释放锁。
    
## CyclicBarrier和CountDownLatch的区别

两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：
（1）CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行
（2）CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务
（3）CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了


## Volatile关键字的作用
volatile关键字的作用主要有两个：
（1）多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据
（2）代码底层执行不像我们看到的高级语言—-Java程序这么简单，它的执行是Java代码–>字节码–>根据字节码执行对应的C/C++代码–>C/C++代码被编译成汇编语言–>和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率
从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。


## sleep方法和wait方法有什么区别

这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器


## ThreadLocal作用
简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了

## 怎么理解多线程的上下文切换

多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程


## 如果你提交任务时，线程池队列已满，这时会发生什么



什么是CAS




Semaphore有什么作用





