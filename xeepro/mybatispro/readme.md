# MySQL

## 数据库的三范式是什么？
    1、属性不可再分
    2、满足第一范式，不存在部分依赖
    3、满足第二范式，不存在传递依赖

## 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？
    与版本与引擎有关系。
    在myisam引擎中，此时是8，因为myisam表会把自增主键的最大ID记录到数据文件里，重启后，最大ID不会丢失。

    在innoDB中，此时id可能是8也可能是6，与mysql版本有关系。
    mysql8之前是6，innodb表会把自增主键的最大ID记录到内存中，所以重启MYSQL，自增主键的最大ID会丢失，
    数据库会重新计算最大ID，将其存在内存。
    mysql8之后，每次对数据库进行更改都会写入重做日志，所以不会丢失最大ID。

## 说一下 ACID 是什么？

	A：原子性   undo log
	C：一致性   其他一起
	I：隔离性   锁、mvcc
	D：持久性   redo log
    两阶段提交法  binlong  redolog 都提交了，才算成功

## char 和 varchar 的区别是什么？

    char表示定长字符串，长度是固定的，如果插入数据的长度小于char的固定长度，则用空格填充，因为长度是固定的，
    所以存取速度要比varchar快，但是会占据多余的空间，是空间换时间的做法。

    varchar表示可变字符串，长度是可变的，插入的数据是多长，就按多长来存储，varchar存取速度慢，但是不多占空间，
    是时间换空间的做法。

    日常设计中，对于长度相对固定的字符串使用char，对于长度不确定的用varchar。

## MySQL 索引是怎么实现的？

    索引 排好序的数据结构
    mysql中，主流的索引都是使用B+树实现的
    B+树的特点:
    B+树能显著减少IO次数，提高效率
    B+树的查询效率更加稳定，因为数据放在叶子节点
    B+树能提高范围查询的效率，因为叶子节点指向下一个叶子节点

## 怎么验证 MySQL 的索引是否满足需求？

    使用explain查看SQL是如何执行查询语句


## 说一下数据库的事务隔离？

    事务隔离级别：
    1： 读未提交
    2： 读已提交
    3： 可重复读  mysql默认隔离级别
	4： 串行化（序列化）


## 说一下 MySQL 常用的引擎？

    1：Innodb
    2：myIsam
    3：hash
    Innodb与myIsam区别：
    1、Innodb支持事务，myIsam不支持
    2、Innodb支持行锁，myIsam支持表锁
    3、Innodb引擎的存储结构包含了数据和索引在一个文件，myIsam中索引文件和数据文件是分开的

## 说一下 MySQL 的行锁和表锁？

    行锁：开销小，性能高，锁粒度小，会死锁，并发高
    表锁：开销大，性能差一些，锁粒度大，不会造成死锁，并发低

## MySQL 问题排查都有哪些手段？
    使用explain命令查询SQL语句。
    开启慢查询日志，查看慢查询的SQL。
    使用show processlist命令查看当前所有连接信息。

## 如何做 MySQL 的性能优化？
	1数据库层面：
		为搜索字段创建索引。
		开启慢查询日志，对慢SQL语句进行优化，例如：不使用select * ，效率极低；查询大量记录，使用limit分页。
		选择适合的存储引擎。
		使用explain查询执行计划进行具体的sql优化操作
	2：硬件层面
		选择合适的cpu、内存
		
# MyBatis

##MyBatis 中 #{}和 ${}的区别是什么？

    1.相同点：
    #{}：都可以获取map中的值或者pojo对象属性的值；
    ${}：都可以获取map中的值或者pojo对象属性的值；

    区别：　　
    #{}：是以预编译的形式，将参数设置到sql语句中(?,?,?)的形式，相当于原生JDBC中的PreparedStatement，
    可以防止sql注入；
    ${}：取出的值直接拼接在sql语句中，会有安全问题

##  MyBatis 有几种分页方式？

    1、第一种分页，全部查出来，然后在前端进行分页，这种分页数据量大的时候，性能会受到影响，甚至不可用。

    2、第二种分页，使用limit，
    前端传进来页码和每页的条数，在sql使用limit进行分页查询。--前10条记录：（第一页）
    SELECT * FROM 表名 LIMIT 0,10;
    或者
    SELECT * FROM 表名 LIMIT 10;

    3、第三种分页方式，用RowBounds分页，创建RowBounds对象，使用有参传开始的条数（（page -1）*pagesize）和
    每页几条数据(pagesize)，调用mapper方法讲RowBounds对象传递进去。

    4、使用pageHelper插件分页、主要是通过mybatis拦截器实现的。

## RowBounds 是一次性查询全部结果吗？为什么？

    不是。
    mybatis是对jdbc进行封装处理的，在jdbc里有一个FetchSize的配置，它规定了每次最多从数据库中查询多少条数的
    数据，若是查询的数据很多，它会在执行next()时，再去查询其它数据。这样能有效的防止内存溢出。


## MyBatis 逻辑分页和物理分页的区别是什么？
  
    1.物理分页

    物理分页就是数据库本身提供了分页方式，如MySQL的limit，oracle的rownum ，好处是效率高，不好的地方就
    是不同数据库有不同的搞法。自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。

    2.逻辑分页

    逻辑分页利用游标分页，好处是所有数据库都统一，坏处就是效率低。

    使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。


## MyBatis 是否支持延迟加载？延迟加载的原理是什么？

    MyBatis支持延迟加载。
    延迟加载是指在查询对象时，只加载其基本属性，而将关联对象的数据暂不加载，等到真正需要使用关联对象时
    再去查询加载其数据的一种技术。
    MyBatis通过在映射文件中配置lazyLoadingEnabled属性来开启延迟加载。
    原理是当查询对象时，只加载对象的基本属性，而对于延迟加载的关联对象，只在真正需要使用时，通过创建代理对象，
    再次向数据库查询加载其数据。

##  说一下 MyBatis 的一级缓存和二级缓存？

    一级缓存与二级缓存的区别
    1.作用范围
    一级缓存的作用范围是 SqlSession 的生命周期，二级缓存的作用范围是整个应用程序的生命周期。

    2.实现方式
    一级缓存是通过 SqlSession 内置的一个 HashMap 来实现的，而二级缓存则是通过配置 Cache 接口来实现的。

    3.共享机制
    一级缓存只能在同一个 SqlSession 内部共享，二级缓存可以在多个 SqlSession 之间共享。

    4.缓存规则
    一级缓存默认开启并且无法关闭；二级缓存需要手动开启并进行配置。

## MyBatis缓存原理
    MyBatis 的缓存本质上是一个 HashMap，它的键是查询语句和参数的组合，值是查询结果。当我们执行一个查询时，
    MyBatis 会先从缓存中查找对应的查询结果，如果缓存中存在，则直接返回缓存的结果；如果缓存中不存在，则从数据
    库中查询数据，并将查询结果存入缓存中。每个 SqlSession 都有自己的缓存，因此在不同的 SqlSession 中
    执行同一个查询语句，它们所使用的缓存是不同的。同时，MyBatis 的缓存是基于引用计数的机制实现的，当查询
    语句被多次引用时，缓存的引用计数会加 1，只有当引用计数为 0 时，缓存才会被真正的清除。

## MyBatis 有哪些执行器（Executor）？

    MyBatis框架提供了三种不同的执行器(Executor)类型，用于执行SQL语句和映射语句：

    1.SimpleExecutor(简单执行器)
    这是默认的执行器类型。它每次执行都会创建一个Statement对象，并立即执行SQL语句。这种执行器不支持事务，
    每次都会关闭Statement对象，适用于简单的查询场景。
    2.ReuseExecutor(重用执行器)
    这种执行器重用预处理的Statement对象。它会缓存Statement对象，当需要执行相同的SQL语句时，会
    直接使用缓存的Statement对象，而不是每次都创建新的对象。这种执行器也不支持事务。
    3.BatchExecutor(批处理执行器)
    这种执行器用于批量操作，可以一次执行多个SQL语句。它会将相同类型的SQL语句分组，并使用JDBC的批处理功能
    执行。这种执行器可以提高性能，尤其适用于需要执行大量相同类型SQL语句的场景，如批量插入或更新操作。

##  MyBatis 分页插件的实现原理是什么？
    MyBatis 分页插件通过拦截 Executor 中的 Query 操作，对 SQL 语句进行改写和增强，在 SQL 执行前后处理
    分页逻辑。插件的核心类是 PageInterceptor，下面简要说明其具体的工作原理：
    1、在 MyBatis 的配置文件中，需要添加 PageInterceptor 类，并设置相应的参数：pageSqlId（SQL ID）、
    数据库类型、分页 SQL 的分类（正则表达式方式等）；
    2、当我们的查询请求经过SqlSessionFactory,关闭 SqlSession时代理执行这个plugin.wrap方法，就会把当
    前分页拦截器注入到Executor对象的链式调用中，拦截Query操作并按分页逻辑返回结果；
    3、当 Executor 查询操作触发时，PageInterceptor 拦截它并对查询语句进行重新构造，以符合分页的需求。
    具体地说，它通过拼接 limit 和 offset 实现了翻页逻辑。例如，在 MySQL 中，可以使用 LIMIT m, n 模式对
    每一页中的记录进行分割;
    4、为了减轻内存压力，PageInterceptor 可以选择通过 RowBounds 对象来实现分页。它的处理逻辑如下：
    根据传入标准的参数构造带偏移量的 RowBounds 对象；
    传递 RowBounds 对象进行SQL执行；
    根据 RowBounds 偏移量和限制将结果集进行截取。
    
    总结： MyBatis 的分页插件机制通过拦截 Executor 接口中的操作完成了对 SQL 语句的重写，并基于 limit 和 offset 完成了分页的功能。它还提供了优秀和灵活性许多的配置选项，包括 RowBounds 等机制，允许你根据需求选择使用合适的分页方式。因此，MyBatis 分页插件在开发过程中可以很好的支持数据查询的效率以及内存压力，保证 User Experience的体验和金标质量。

##  MyBatis 如何编写一个自定义插件？

    第一步，实现Plugin接口。这个接口有两个方法需要实现，分别是intercept()和plugin()方法。其中intercept()
    方法为核心方法，它包括三个参数，分别是目标对象target和两个可以不用的参数，Invocation和Object[]。
    intercept()方法的实现决定了我们自定义的逻辑，可以在这里添加一些额外的业务逻辑，比如缓存等等。

    第二步，为我们自定义的插件生成代理对象。可以通过Plugin类的wrap()方法实现，它接收两个参数，分别是目标
    对象target和我们自定义的插件。生成的代理对象包含了我们自定义的逻辑。

    第三步，选择一个需要进行增强的对象以及需要增强的方法。MyBatis四大对象分别是拦截器、执行器、参数处理器
    和结果处理器，可以选择其中任意一个对象，但要注意需要增强的方法在该对象中的位置。

    第四步，使用Intercepts注解进行注释。在我们自定义的插件类上添加@Intercepts注解，其中需要指定拦截对象
    和要拦截的方法。需要注意的是，一个插件可以对多个拦截器进行增强，此时可以添加多个@Signature注解。

    MyBatis自定义插件可以用于增强性能、安全性和可维护性。比如，可以使用一个插件来记录每个SQL语句的执行
    时间、数量、异常等信息，方便我们更好地进行监控和调试。还可以使用一个插件来对SQL语句进行敏感词过滤，
    确保数据的安全性。

    总之，MyBatis自定义插件提供了一个很好的机会来增强MyBatis的功能，使其更能够满足我们的需求。在互联网
    场景下，我们需要经常对数据进行操作，并且需要保证数据的安全性和可维护性，自定义插件的使用可以很好地满足
    这些需求。





